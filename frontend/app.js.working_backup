/**
 * EV Charging Voice Assistant - ENHANCED DEBUG Frontend
 * Includes comprehensive logging to diagnose audio issues
 */

class EVChargingApp {
    constructor() {
        this.room = null;
        this.isConnected = false;
        this.isMuted = false;
        this.localAudioTrack = null;
        this.transcripts = [];

        this.initializeElements();
        this.attachEventListeners();
        
        console.log('üöÄ EVChargingApp initialized');
    }

    initializeElements() {
        // Buttons
        this.connectBtn = document.getElementById('connectBtn');
        this.disconnectBtn = document.getElementById('disconnectBtn');
        this.muteBtn = document.getElementById('muteBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.cancelBtn = document.getElementById('cancelBtn');

        // Status elements
        this.connectionStatus = document.getElementById('connectionStatus');
        this.statusDot = document.getElementById('statusDot');
        this.statusText = document.getElementById('statusText');
        this.connectionInfo = document.getElementById('connectionInfo');
        this.waveContainer = document.getElementById('waveContainer');

        // Transcription elements
        this.transcriptionContent = document.getElementById('transcriptionContent');
        this.languageIndicator = document.getElementById('languageIndicator');

        // Modal elements
        this.connectionModal = document.getElementById('connectionModal');
        this.connectionForm = document.getElementById('connectionForm');
        this.roomNameInput = document.getElementById('roomName');
        this.participantNameInput = document.getElementById('participantName');
    }

    attachEventListeners() {
        this.connectBtn.addEventListener('click', () => this.showConnectionModal());
        this.disconnectBtn.addEventListener('click', () => this.disconnect());
        this.muteBtn.addEventListener('click', () => this.toggleMute());
        this.clearBtn.addEventListener('click', () => this.clearTranscripts());
        this.cancelBtn.addEventListener('click', () => this.hideConnectionModal());
        this.connectionForm.addEventListener('submit', (e) => this.handleConnectionSubmit(e));
    }

    showConnectionModal() {
        this.connectionModal.classList.add('active');
    }

    hideConnectionModal() {
        this.connectionModal.classList.remove('active');
    }

    async handleConnectionSubmit(e) {
        e.preventDefault();

        const roomName = this.roomNameInput.value.trim();
        const participantName = this.participantNameInput.value.trim();

        if (!roomName || !participantName) {
            alert('Please fill in all fields');
            return;
        }

        this.hideConnectionModal();
        await this.connect(roomName, participantName);
    }

    async connect(roomName, participantName) {
        try {
            console.log('üîå Starting connection process...');
            this.updateStatus('connecting', 'Connecting...');
            this.connectionInfo.innerHTML = '<p>Connecting to voice assistant...</p>';

            // Get access token from backend
            console.log('üé´ Requesting access token...');
            const connectionConfig = await this.getAccessToken(roomName, participantName);
            const { token, url: livekitUrl, deployment } = connectionConfig;
            console.log(`‚úì Token received for ${deployment} deployment`);
            console.log(`‚úì LiveKit URL: ${livekitUrl}`);

            // Initialize LiveKit room
            console.log('üè† Creating LiveKit room...');
            this.room = new LivekitClient.Room({
                adaptiveStream: true,
                dynacast: true,
            });
            console.log('‚úì Room created');

            // Set up event listeners BEFORE connecting
            this.setupRoomEventListeners();

            // Connect to the room
            console.log('üîó Connecting to room...');
            await this.room.connect(livekitUrl, token);
            console.log('‚úì Connected to room');
            console.log(`  - Room name: ${this.room.name}`);
            console.log(`  - Room SID: ${this.room.sid}`);
            console.log(`  - Local participant: ${this.room.localParticipant.identity}`);
            console.log(`  - Remote participants: ${this.room.remoteParticipants.size}`);

            // Set up local audio track
            console.log('üé§ Setting up local audio...');
            await this.setupLocalAudio();

            this.isConnected = true;
            this.updateStatus('connected', 'Connected');
            this.connectionInfo.innerHTML = `
                <p>‚úì Connected! Start speaking to interact with the assistant.</p>
                <p><strong>Deployment:</strong> ${deployment === 'cloud' ? 'LiveKit Cloud' : 'Local LiveKit Server'}</p>
                <p><strong>Server:</strong> ${livekitUrl}</p>
                <p><strong>Room:</strong> ${this.room.name}</p>
                <p><strong>Your ID:</strong> ${this.room.localParticipant.identity}</p>
            `;
            this.waveContainer.classList.add('active');

            // Enable/disable buttons
            this.connectBtn.disabled = true;
            this.disconnectBtn.disabled = false;
            this.muteBtn.disabled = false;

            console.log('‚úÖ Connection complete! You can now speak.');

        } catch (error) {
            console.error('‚ùå Connection error:', error);
            this.updateStatus('disconnected', 'Connection Failed');
            this.connectionInfo.innerHTML = `<p style="color: var(--danger-color);">Connection failed: ${error.message}</p>`;

            if (error.message.includes('token')) {
                alert('Failed to get access token. Please make sure the backend server is running.');
            } else if (error.message.includes('connect')) {
                alert('Failed to connect to the LiveKit server. Please ensure the configured LiveKit deployment is reachable.');
            }
        }
    }

    async getAccessToken(roomName, participantName) {
        try {
            let apiBaseUrl = window.location.origin;
            if (!apiBaseUrl.startsWith('http')) {
                apiBaseUrl = 'http://localhost:5000';
            }

            console.log(`Fetching token from: ${apiBaseUrl}/api/token`);
            const response = await fetch(`${apiBaseUrl}/api/token`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    roomName: roomName,
                    participantName: participantName,
                }),
            });

            if (!response.ok) {
                throw new Error('Failed to get access token');
            }

            const data = await response.json();
            return data;

        } catch (error) {
            console.error('Token fetch error:', error);
            throw new Error('Cannot fetch token. Please ensure the FastAPI server is running.');
        }
    }

    setupRoomEventListeners() {
        console.log('üì° Setting up room event listeners...');

        // Track published
        this.room.on(LivekitClient.RoomEvent.TrackPublished, (publication, participant) => {
            console.log('üì¢ Track published:', {
                participant: participant.identity,
                trackSid: publication.trackSid,
                kind: publication.kind,
                source: publication.source,
            });
        });

        // Track subscribed
        this.room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
            console.log('üéß Track subscribed:', {
                participant: participant.identity,
                trackSid: track.sid,
                kind: track.kind,
            });

            if (track.kind === LivekitClient.Track.Kind.Audio) {
                console.log('üîä AUDIO TRACK SUBSCRIBED - Agent audio will play');
                const audioElement = track.attach();
                audioElement.autoplay = true;
                document.body.appendChild(audioElement);
                console.log('‚úì Audio element attached to DOM');
            }
        });

        // Track unsubscribed
        this.room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track, publication, participant) => {
            console.log('üîá Track unsubscribed:', {
                participant: participant.identity,
                trackSid: track.sid,
            });
            track.detach().forEach(element => element.remove());
        });

        // Data received (for transcriptions)
        this.room.on(LivekitClient.RoomEvent.DataReceived, (payload, participant) => {
            console.log('üì¶ Data received from', participant?.identity || 'unknown');
            
            const decoder = new TextDecoder();
            const data = JSON.parse(decoder.decode(payload));
            console.log('Data content:', data);

            if (data.type === 'transcription') {
                const roleFromPayload = data.role || (participant?.identity === this.room?.localParticipant?.identity ? 'user' : 'assistant');
                this.addTranscript(data.text, data.isFinal, roleFromPayload, data.language);
            }
        });

        // Participant connected
        this.room.on(LivekitClient.RoomEvent.ParticipantConnected, (participant) => {
            console.log('üë§ Participant connected:', {
                identity: participant.identity,
                sid: participant.sid,
                isAgent: participant.identity.includes('agent') || participant.identity.includes('assistant'),
            });
        });

        // Participant disconnected
        this.room.on(LivekitClient.RoomEvent.ParticipantDisconnected, (participant) => {
            console.log('üëã Participant disconnected:', participant.identity);
        });

        // Disconnected
        this.room.on(LivekitClient.RoomEvent.Disconnected, (reason) => {
            console.log('üîå Disconnected from room:', reason);
            this.handleDisconnection();
        });

        // Connection quality changed
        this.room.on(LivekitClient.RoomEvent.ConnectionQualityChanged, (quality, participant) => {
            console.log('üì∂ Connection quality:', {
                participant: participant.identity,
                quality: quality,
            });
        });

        // Media devices error
        this.room.on(LivekitClient.RoomEvent.MediaDevicesError, (error) => {
            console.error('üé§‚ùå Media devices error:', error);
            alert('Microphone error: ' + error.message);
        });

        console.log('‚úì Event listeners set up');
    }

    async setupLocalAudio() {
        try {
            console.log('üé§ Requesting microphone access...');
            
            // Check if browser supports getUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Your browser does not support microphone access');
            }

            // Create local audio track
            console.log('Creating local audio track...');
            this.localAudioTrack = await LivekitClient.createLocalAudioTrack({
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
            });
            console.log('‚úì Local audio track created:', {
                sid: this.localAudioTrack.sid,
                enabled: this.localAudioTrack.isEnabled,
                muted: this.localAudioTrack.isMuted,
            });

            // Publish the track to the room
            console.log('üì§ Publishing audio track to room...');
            const publication = await this.room.localParticipant.publishTrack(this.localAudioTrack);
            console.log('‚úì Audio track published:', {
                trackSid: publication.trackSid,
                kind: publication.kind,
                source: publication.source,
            });

            // Log audio level to verify microphone is working
            this.monitorAudioLevel();

            console.log('‚úÖ Local audio setup complete');

        } catch (error) {
            console.error('‚ùå Failed to set up local audio:', error);
            alert(`Failed to access microphone: ${error.message}\n\nPlease check:\n1. Microphone permissions in browser\n2. Microphone is not used by another application\n3. Using HTTPS or localhost`);
            throw error;
        }
    }

    monitorAudioLevel() {
        // Monitor audio level to confirm microphone is working
        let lastLogTime = 0;
        const logInterval = 2000; // Log every 2 seconds

        const checkAudio = () => {
            if (!this.localAudioTrack || !this.isConnected) return;

            const now = Date.now();
            if (now - lastLogTime >= logInterval) {
                // The track has an audioLevel property that we can check
                console.log('üé§ Microphone status:', {
                    enabled: this.localAudioTrack.isEnabled,
                    muted: this.localAudioTrack.isMuted,
                    // Note: audioLevel might not be available on all track types
                });
                lastLogTime = now;
            }

            if (this.isConnected) {
                requestAnimationFrame(checkAudio);
            }
        };

        checkAudio();
    }

    async disconnect() {
        console.log('üîå Disconnecting...');
        
        if (this.localAudioTrack) {
            try {
                console.log('üì§ Unpublishing local audio track...');
                await this.room.localParticipant.unpublishTrack(this.localAudioTrack);
                console.log('‚úì Track unpublished');
            } catch (error) {
                console.warn('Unable to unpublish local audio track cleanly:', error);
            }
        }

        if (this.room) {
            console.log('üëã Disconnecting from room...');
            await this.room.disconnect();
            console.log('‚úì Disconnected');
        }
        
        this.handleDisconnection();
    }

    handleDisconnection() {
        this.isConnected = false;
        this.updateStatus('disconnected', 'Disconnected');
        this.connectionInfo.innerHTML = '<p>Click "Connect" to start talking with the voice assistant</p>';
        this.waveContainer.classList.remove('active');

        this.connectBtn.disabled = false;
        this.disconnectBtn.disabled = true;
        this.muteBtn.disabled = true;

        this.isMuted = false;
        this.updateMuteButton();

        if (this.localAudioTrack) {
            this.localAudioTrack.stop();
            this.localAudioTrack = null;
        }

        this.room = null;
        console.log('‚úì Cleanup complete');
    }

    async toggleMute() {
        if (!this.localAudioTrack) return;

        this.isMuted = !this.isMuted;

        if (this.isMuted) {
            console.log('üîá Muting microphone');
            await this.localAudioTrack.mute();
        } else {
            console.log('üîä Unmuting microphone');
            await this.localAudioTrack.unmute();
        }

        this.updateMuteButton();
        console.log(`Microphone ${this.isMuted ? 'muted' : 'unmuted'}`);
    }

    updateMuteButton() {
        if (this.isMuted) {
            this.muteBtn.innerHTML = '<span class="btn-icon">üîá</span><span class="btn-text">Unmute</span>';
            this.muteBtn.style.background = 'var(--danger-color)';
            this.muteBtn.style.color = 'white';
        } else {
            this.muteBtn.innerHTML = '<span class="btn-icon">üîä</span><span class="btn-text">Mute</span>';
            this.muteBtn.style.background = '';
            this.muteBtn.style.color = '';
        }
    }

    updateStatus(status, text) {
        this.statusText.textContent = text;
        this.statusDot.className = 'status-dot';

        if (status === 'connected') {
            this.statusDot.classList.add('connected');
        } else if (status === 'connecting') {
            this.statusDot.classList.add('connecting');
        }
    }

    addTranscript(text, isFinal, role, languageHint) {
        if (!text) return;

        console.log(`üìù Adding transcript: [${role}] "${text}" (final: ${isFinal})`);

        const language = languageHint || this.detectLanguage(text);
        this.updateLanguageIndicator(language);

        const emptyState = this.transcriptionContent.querySelector('.empty-state');
        if (emptyState) {
            emptyState.remove();
        }

        const lastMessage = this.transcriptionContent.lastElementChild;

        if (lastMessage && lastMessage.dataset.role === role && lastMessage.dataset.final !== 'true') {
            const messageText = lastMessage.querySelector('.message-text');
            messageText.textContent = text;

            if (isFinal) {
                lastMessage.dataset.final = 'true';
                const timeEl = lastMessage.querySelector('.message-time');
                timeEl.textContent = this.getCurrentTimeString();
                this.transcripts.push({ role, text, timestamp: new Date(), language });
            }

            return;
        }

        const messageDiv = this.createTranscriptMessage(role, text, language, isFinal);
        this.transcriptionContent.appendChild(messageDiv);

        if (isFinal) {
            this.transcripts.push({ role, text, timestamp: new Date(), language });
        }

        this.transcriptionContent.scrollTop = this.transcriptionContent.scrollHeight;
    }

    createTranscriptMessage(role, text, language, isFinal) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `transcript-message ${role}`;
        messageDiv.dataset.role = role;
        messageDiv.dataset.final = isFinal ? 'true' : 'false';
        messageDiv.dataset.language = language;

        const timeString = isFinal ? this.getCurrentTimeString() : '';

        messageDiv.innerHTML = `
            <div class="message-label">${role === 'user' ? 'You' : 'Assistant'}</div>
            <div class="message-text">${text}</div>
            <div class="message-time">${timeString}</div>
        `;

        return messageDiv;
    }

    getCurrentTimeString() {
        const now = new Date();
        return now.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    detectLanguage(text) {
        const hindiRegex = /[\u0900-\u097F]/;
        return hindiRegex.test(text) ? 'hi' : 'en';
    }

    updateLanguageIndicator(language) {
        const badge = this.languageIndicator.querySelector('.lang-badge');
        if (language === 'hi') {
            badge.textContent = 'HI';
            badge.classList.add('hindi');
        } else {
            badge.textContent = 'EN';
            badge.classList.remove('hindi');
        }
    }

    clearTranscripts() {
        if (this.transcripts.length === 0) return;

        if (confirm('Are you sure you want to clear all transcripts?')) {
            this.transcripts = [];
            this.transcriptionContent.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">üí¨</div>
                    <p>Conversation transcription will appear here</p>
                </div>
            `;
            console.log('üóëÔ∏è Transcripts cleared');
        }
    }
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log('='.repeat(80));
    console.log('EV CHARGING VOICE ASSISTANT - DEBUG MODE');
    console.log('='.repeat(80));
    
    // Check if LiveKit is loaded
    if (typeof LivekitClient === 'undefined') {
        console.error('‚ùå LivekitClient library failed to load!');
        alert('Error: LivekitClient library failed to load. Please check your internet connection and refresh the page.');
        return;
    }

    console.log('‚úì LivekitClient loaded:', LivekitClient.version || 'version unknown');
    
    window.app = new EVChargingApp();
    console.log('‚úì App initialized');
    console.log('='.repeat(80));
    console.log('Ready! Click "Connect" to start.');
    console.log('All events will be logged to this console.');
    console.log('='.repeat(80));
});